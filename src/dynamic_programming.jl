"""
Finds the optimal sequence of haplotype pairs across all windows 
such that number of switch points is minimized. 

# Inputs
- `w`: Current window
- `happair`: Haplotype pair in current window being considered. 
- `haplotype_set`: A vector of vectors. `haplotype_set[1]` stores all pairs of haplotypes in window 1 in a vector, and so on. 
- `λ`: Error associated with 1 mismatch when comparing 2 pairs of haplotypes. e.g. (h1, h2) vs (h1, h3) have error λ. 
"""
function connect_happairs!(
    haplotype_set::Vector{Vector{T}}; 
    λ::Float64 = 1.0,
    memory   = [Dict{T, Float64}() for i in 1:(length(haplotype_set) - 1)],
    sol_path = Vector{T}(undef, length(haplotype_set)),
    path_err = [Inf for i in 1:length(haplotype_set)]
    ) where T <: Tuple{Int, Int}

    # reset storage
    empty!.(memory)
    path_err .= Inf

    best_err  = Inf
    for happair in haplotype_set[1]
        # calculate current happair's subtree error resursively
        happair_err = Inf
        best_pair2  = (0, 0)
        for pair in haplotype_set[2]
            err = pair_error(happair, pair) + _connect_happairs!(2, pair, haplotype_set, λ = λ, memory = memory, solution_path = sol_path, path_err = path_err)
            if err < happair_err
                best_pair2  = pair
                happair_err = err
            end
        end

        # record happair if it is better than previously tested happairs
        if happair_err < best_err
            best_err    = happair_err
            sol_path[1] = happair
            sol_path[2] = best_pair2
        end

        # record best error for current subtree
        memory[1][happair] = happair_err
    end

    return sol_path, memory, best_err
end
connect_happairs(haplotype_set; args...) = connect_happairs!(haplotype_set, args...)

"""
# Inputs
- `w`: Current window
- `happair`: Haplotype pair in current window being considered. 
- `haplotype_set`: A vector of vectors. `haplotype_set[1]` stores all pairs of haplotypes in window 1 in a vector, and so on. 
- `λ`: Error associated with 1 mismatch when comparing 2 pairs of haplotypes. e.g. (h1, h2) vs (h1, h3) have error λ. 
"""
function _connect_happairs!(
    w::Int,
    happair::T, 
    haplotype_set::Vector{Vector{T}};
    λ::Float64 = 1.0,
    memory = [Dict{T, Float64}() for i in 1:(length(haplotype_set) - 1)],
    solution_path = Vector{T}(undef, length(haplotype_set)),
    path_err = [Inf for i in 1:length(haplotype_set)]
    ) where T <: Tuple{Int, Int}

    if w == length(haplotype_set)
        return 0.0 # last window contributes no extra error
    elseif haskey(memory[w], happair)
        return memory[w][happair] # quick lookup
    else
        # recursion: solve subtree generated by happair
        best_err = Inf
        best_next_pair = (0, 0)
        for pair in haplotype_set[w + 1]
            err = pair_error(happair, pair) + _connect_happairs!(w + 1, pair, haplotype_set, λ = λ, memory = memory, solution_path = solution_path, path_err = path_err)
            # println("pair $happair's next pair = ", pair, " has error = $err") # proof that memoization is working

            if err < best_err
                # keep track of error in current subtree
                best_next_pair = pair
                best_err = err
            end
        end

        # if error for happair better than all subtree in current window, save this error
        if best_err < path_err[w]
            path_err[w] = best_err
            solution_path[w + 1] = best_next_pair
        end

        # record best error for current subtree
        memory[w][happair] = best_err
        return best_err
    end
end

function pair_error(pair1::T, pair2::T; λ::Real = 1.0) where T <: Tuple{Int, Int}
    difference = zero(eltype(λ))
    if pair1[1] != pair2[1] && pair1[1] != pair2[2]
        difference += one(eltype(λ))
    end
    if pair1[2] != pair2[1] && pair1[2] != pair2[2]
        difference += one(eltype(λ))
    end
    return λ * difference
end
