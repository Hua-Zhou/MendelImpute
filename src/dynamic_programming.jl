"""
Finds the optimal sequence of haplotype pairs across all windows 
such that number of switch points is minimized. 

# Inputs
- `w`: Current window
- `happair`: Haplotype pair in current window being considered. 
- `haplotype_set`: A vector of vectors. `haplotype_set[1]` stores all pairs of haplotypes in window 1 in a vector, and so on. 
- `λ`: Error associated with 1 mismatch when comparing 2 pairs of haplotypes. e.g. (h1, h2) vs (h1, h3) have error λ. 
"""
function connect_happairs!(
    sol_path::Vector{T},
    memory::Vector{Dict{T, Float64}},
    path_err::Vector{Float64},
    haplotype_set::Vector{Vector{T}};
    λ::Float64 = 1.0,
    ) where T <: Tuple{Int, Int}

    # reset storage
    empty!.(memory)
    path_err .= Inf

    # preallocate returning values
    best_err  = Inf

    for happair in haplotype_set[1]
        # calculate current happair's subtree error resursively
        err = _connect_happairs!(sol_path, memory, path_err, haplotype_set, λ, 1, happair)
        if err < best_err
            best_err    = err
            sol_path[1] = happair
        end

        # record error for current subtree
        memory[1][happair] = err
    end

    return best_err
end

function connect_happairs(
    haplotype_set::Vector{Vector{T}};
    λ::Float64 = 1.0
    ) where T <: Tuple{Int, Int}

    # allocate working arrays
    windows  = length(haplotype_set)
    memory   = [Dict{T, Float64}() for i in 1:(windows - 1)]
    sol_path = Vector{T}(undef, windows)
    path_err = [Inf for i in 1:windows]

    # computational routine
    best_err = connect_happairs!(sol_path, memory, path_err, haplotype_set, λ = λ)

    return sol_path, memory, path_err, best_err
end

"""
Helper function that calculates the optimal subtree starting with `happair` as root node
in window `w`. 

# Inputs
- `w`: Current window
- `happair`: Haplotype pair in current window being considered. 
- `haplotype_set`: A vector of vectors. `haplotype_set[1]` stores all pairs of haplotypes in window 1 in a vector, and so on. 
- `λ`: Error associated with 1 mismatch when comparing 2 pairs of haplotypes. e.g. (h1, h2) vs (h1, h3) have error λ. 
"""
function _connect_happairs!(
    solution_path::Vector{T},
    memory::Vector{Dict{T, Float64}},
    path_err::Vector{Float64},
    haplotype_set::Vector{Vector{T}},
    λ::Float64,
    w::Int,
    happair::T, 
    ) where T <: Tuple{Int, Int}

    if w == length(haplotype_set)
        return 0.0 # last window contributes no extra error
    elseif haskey(memory[w], happair)
        return memory[w][happair] # quick lookup
    else
        # recursion: solve subtree generated by happair
        best_err = Inf
        best_next_pair = (0, 0)
        for pair in haplotype_set[w + 1]
            err = pair_error(happair, pair) + _connect_happairs!(solution_path, memory, path_err, haplotype_set, λ, w + 1, pair)
            # println("pair $happair's next pair = ", pair, " has error = $err") # proof that memoization is working

            if err < best_err
                # keep track of error in current subtree
                best_next_pair = pair
                best_err = err
            end
        end

        # if error for happair better than all subtree in current window, save this error
        if best_err < path_err[w]
            path_err[w] = best_err
            solution_path[w + 1] = best_next_pair
        end

        # record best error for current subtree
        memory[w][happair] = best_err
        return best_err
    end
end

function pair_error(pair1::T, pair2::T; λ::Real = 1.0) where T <: Tuple{Int, Int}
    difference = zero(eltype(λ))
    if pair1[1] != pair2[1] && pair1[1] != pair2[2]
        difference += one(eltype(λ))
    end
    if pair1[2] != pair2[1] && pair1[2] != pair2[2]
        difference += one(eltype(λ))
    end
    return λ * difference
end
